## Отчет по лабораторной работе №3
**Группа ИС-21, Мавлютов Р. Э.**

*1. Основные параметры производительности PostgreSQL*

> `shared_buffers`  
> Определяет объем памяти, выделяемый PostgreSQL для кэширования данных (буферов). Это основной параметр, влияющий на производительность чтения и записи.  
> Рекомендуемое значение: 25–40% от общей оперативной памяти (RAM).  
> `work_mem`  
> Определяет объем памяти, выделяемый для каждой операции сортировки или хеш-таблицы в запросах (например, ORDER BY, DISTINCT, JOIN).  
> Рекомендуемое значение: Зависит от количества одновременных соединений. Общее правило: (work_mem * max_connections) не должно превышать 50% RAM.  
> `maintenance_work_mem`  
> Определяет объем памяти, выделяемый для операций обслуживания (например, создание индексов, VACUUM, ANALYZE).  
> Рекомендуемое значение: 5–10% от RAM.  
> `effective_cache_size`  
> Оценивает объем памяти, доступный для кэширования данных операционной системой (OS cache). Этот параметр используется планировщиком запросов для оценки стоимости операций.  
> Рекомендуемое значение: 50–75% от RAM.
> 
> Параметры были установлены в файле конфигурации PostgreSQL (`postgresql.conf`) с учетом объема оперативной памяти виртуальной машины. После изменения параметров служба PostgreSQL была перезапущена командой:  
> `sudo systemctl restart postgresql`. Были отображены текущие настройки через `SHOW`
> 
> <img src="/Lab 3/screens/1.png" title="Основные параметры производительности PostgreSQL" width="auto" height="592.5"/> 

 *2. Создание и анализ индексов*

> При помощи `generate_series` была наполнена таблица. Ключевые столбцы таблицы для проведения анализа: возраст (age), целочисленное и (text_id), строковое.  
> По этим столбцам были созданы индексы и запущены команды `EXPLAIN ANALYZE`. Существуют разные типы индексов под разные задачи, так, в моем случае GIST и GIN несовместимы со строковым типом.
> 
> Последовательный перебор, очевидно, оказался медленнее чем поиск с индексом. В скане с индексом, в случае строковой переменной, подготовка к поиску занимает большее время, так как происходит поиск необходимого индекса, но сам процесс длится гораздо быстрее. Также для ускорения обычного скана, наблюдается использование параллельных потоков поиска.
> 
> <img src="/Lab 3/screens/2.png" title="Создание и анализ индексов" width="auto" height="592.5"/> 
> <img src="/Lab 3/screens/3.png" title="Создание и анализ индексов" width="auto" height="592.5"/> 

 *3. Хранимые функции*

> Была создана функция, которая проверяет возраст, а затем вставляет корректное значение в таблицу. Выводится результат операции.  
> Была выведена таблица со вставленным значением.
> 
> <img src="/Lab 3/screens/4.png" title="Хранимые функции" width="auto" height="592.5"/> 

 *4. Триггеры*

> Была создана функция, отфильтровывающая недопустимое слово. Далее был создан тригер, который применяет функцию ко всем новым данным, или же обновлениям текущих данных.
> 
> <img src="/Lab 3/screens/5.png" title="Хранимые функции" width="auto" height="592.5"/> 

 *6. Мониторинг состояния системы*

> Был вызван монитринг ресурсов для postgre командой `htop -u postgre`  
> `a) PID` Идентификатор процесса (Process ID).  
> `b) USER` Пользователь, от имени которого запущен процесс.  
> `c) PRI` Приоритет процесса (Priority).  
> `d) NI` Значение "nice" (приоритет процесса, заданный пользователем).  
> `e) VIRT` Виртуальная память, выделенная процессу.  
> `f) RES` Физическая память (RAM), используемая процессом.  
> `g) SHR` Общая память (shared memory), используемая процессом.  
> `h) S`  
>     Состояние процесса:  
> ____`R :` Выполняется (Running).  
> ____`S :` Спит (Sleeping).  
> ____`D :` Ожидает завершения операций ввода/вывода (Disk Sleep).  
> ____`Z :` Зомби-процесс (неактивный процесс, ожидающий завершения родительского процесса).  
> ____`T `: Остановлен (Stopped).  
> `i) %CPU` Процент использования CPU процессом.  
> `j) %MEM` Процент использования оперативной памяти (RAM) процессом.  
> `k) TIME+` Общее время, затраченное процессором на выполнение процесса.  
> `l) COMMAND` Команда, которая запустила процесс.  
>    Например, для PostgreSQL это будет что-то вроде /usr/lib/postgresql/14/bin/postgres.`
>
> <img src="/Lab 2/screens/6.png" title="Мониторинг состояния системы" width="auto" height="592.5"/>

 *7. Мониторинг PostgreSQL*

> Был вызван мониторинг состояния процессов postgre
>
> <img src="/Lab 2/screens/7.png" title="Мониторинг PostgreSQL" width="auto" height="592.5"/>
>
> Мониторинг статистики по базам данных
>
> <img src="/Lab 2/screens/8.png" title="Мониторинг PostgreSQL" width="auto" height="592.5"/>
>
> Взаимодействие с командами происходит как в обычной базе данных, со всеми стандартными SQL запросами.  
> Так, мы можем найти нужный нам процесс, отсортировав по возрастанию задержки и удалить его следующими командами:  
> `SELECT pid, usename, datname, state, query, age(clock_timestamp(), query_start) AS runtime`  
> `FROM pg_stat_activity`  
> `WHERE state = 'active'`  
> `ORDER BY runtime DESC;`  
>
> `SELECT pg_terminate_backend(найденный pid);`

 *8. Логирование и анализ логов*

> PostgreSQL  логгирует события, связанные с выполнением запросов, ошибками, контрольными точками и другими внутренними процессами.  
> Операционная система  логгирует события, связанные с запуском/остановкой службы PostgreSQL, ошибками службы, проблемами с памятью, событиями ядра и безопасности.  
> Логи PostgreSQL находятся в дирктории data/log, где - data это основная директория с бд и файлом конфига. Системные логи — в /var/log/ или же доступны по команде `journalctl`  
> Был открыт `journalctl` и стандартный лог postgre:
>
> <img src="/Lab 2/screens/9.png" title="Логирование и анализ логов" width="auto" height="592.5"/>
