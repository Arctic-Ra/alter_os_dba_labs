## Отчет по лабораторной работе №3
**Группа ИС-21, Мавлютов Р. Э.**

*1. Основные параметры производительности PostgreSQL*

> `shared_buffers`  
> Определяет объем памяти, выделяемый PostgreSQL для кэширования данных (буферов). Это основной параметр, влияющий на производительность чтения и записи.  
> Рекомендуемое значение: 25–40% от общей оперативной памяти (RAM).  
> `work_mem`  
> Определяет объем памяти, выделяемый для каждой операции сортировки или хеш-таблицы в запросах (например, ORDER BY, DISTINCT, JOIN).  
> Рекомендуемое значение: Зависит от количества одновременных соединений. Общее правило: (work_mem * max_connections) не должно превышать 50% RAM.  
> `maintenance_work_mem`  
> Определяет объем памяти, выделяемый для операций обслуживания (например, создание индексов, VACUUM, ANALYZE).  
> Рекомендуемое значение: 5–10% от RAM.  
> `effective_cache_size`  
> Оценивает объем памяти, доступный для кэширования данных операционной системой (OS cache). Этот параметр используется планировщиком запросов для оценки стоимости операций.  
> Рекомендуемое значение: 50–75% от RAM.
> 
> Параметры были установлены в файле конфигурации PostgreSQL (`postgresql.conf`) с учетом объема оперативной памяти виртуальной машины. После изменения параметров служба PostgreSQL была перезапущена командой:  
> `sudo systemctl restart postgresql`. Были отображены текущие настройки через `SHOW`
> 
> <img src="/Lab 3/screens/1.png" title="Основные параметры производительности PostgreSQL" width="auto" height="592.5"/> 

 *2. Создание и анализ индексов*

> При помощи `generate_series` была наполнена таблица. Ключевые столбцы таблицы для проведения анализа: возраст (age), целочисленное и (text_id), строковое.  
> По этим столбцам были созданы индексы и запущены команды `EXPLAIN ANALYZE`. Существуют разные типы индексов под разные задачи, так, в моем случае GIST и GIN несовместимы со строковым типом.
> 
> Последовательный перебор, очевидно, оказался медленнее чем поиск с индексом. В скане с индексом, в случае строковой переменной, подготовка к поиску занимает большее время, так как происходит поиск необходимого индекса, но сам процесс длится гораздо быстрее. Также для ускорения обычного скана, наблюдается использование параллельных потоков поиска.
> 
> <img src="/Lab 3/screens/2.png" title="Создание и анализ индексов" width="auto" height="592.5"/> 
> <img src="/Lab 3/screens/3.png" title="Создание и анализ индексов" width="auto" height="592.5"/> 

 *3. Хранимые функции*

> Была создана функция, которая проверяет возраст, а затем вставляет корректное значение в таблицу. Выводится результат операции.  
> Была выведена таблица со вставленным значением.
> 
> <img src="/Lab 3/screens/4.png" title="Хранимые функции" width="auto" height="592.5"/> 

 *4. Триггеры*

> Была создана функция, отфильтровывающая недопустимое слово. Далее был создан триггер, который применяет функцию ко всем новым данным, или же обновлениям существующих данных.
> 
> <img src="/Lab 3/screens/5.png" title="Хранимые функции" width="auto" height="592.5"/> 

 *5. Автоматическая очистка и статистика (VACUUM, ANALYZE)*

>  "Мёртвые" строки - строки, которые были удалены или обновлены, но ещё занимают место в таблице.  
> PostgreSQL использует механизм MVCC  (Multiversion Concurrency Control) для обеспечения согласованности данных при параллельной работе нескольких транзакций:  
>    `Каждая транзакция видит только те данные, которые были актуальны на момент её начала`.  
>    `При обновлении или удалении строки PostgreSQL не изменяет её напрямую, а создаёт новую версию строки (для обновления) или помечает старую строку как "мёртвую" (для удаления).`
> 
> `VACUUM`:  Удаляет "мёртвые" строки и освобождает место.  
> `ANALYZE`:  Обновляет статистику для планировщика запросов.  
>
> <img src="/Lab 2/screens/6.png" title="Мониторинг состояния системы" width="auto" height="592.5"/>

 *7. Мониторинг PostgreSQL*

> Был вызван мониторинг состояния процессов postgre
>
> <img src="/Lab 2/screens/7.png" title="Мониторинг PostgreSQL" width="auto" height="592.5"/>
>
> Мониторинг статистики по базам данных
>
> <img src="/Lab 2/screens/8.png" title="Мониторинг PostgreSQL" width="auto" height="592.5"/>
>
> Взаимодействие с командами происходит как в обычной базе данных, со всеми стандартными SQL запросами.  
> Так, мы можем найти нужный нам процесс, отсортировав по возрастанию задержки и удалить его следующими командами:  
> `SELECT pid, usename, datname, state, query, age(clock_timestamp(), query_start) AS runtime`  
> `FROM pg_stat_activity`  
> `WHERE state = 'active'`  
> `ORDER BY runtime DESC;`  
>
> `SELECT pg_terminate_backend(найденный pid);`

 *8. Логирование и анализ логов*

> PostgreSQL  логгирует события, связанные с выполнением запросов, ошибками, контрольными точками и другими внутренними процессами.  
> Операционная система  логгирует события, связанные с запуском/остановкой службы PostgreSQL, ошибками службы, проблемами с памятью, событиями ядра и безопасности.  
> Логи PostgreSQL находятся в дирктории data/log, где - data это основная директория с бд и файлом конфига. Системные логи — в /var/log/ или же доступны по команде `journalctl`  
> Был открыт `journalctl` и стандартный лог postgre:
>
> <img src="/Lab 2/screens/9.png" title="Логирование и анализ логов" width="auto" height="592.5"/>
